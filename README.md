# Домашнее задание к занятию 4.1: JVM. Организация памяти, сборщики мусора, VisualVM
Задача 1.

// 1. Ниже приведен код, написанный на языке Java. Для того, чтобы перевести программу из исходного кода в код, понятный JVM, требуется компиляция.
// Компилятор javac преобразует исходный код в байт-код. Далее JVM начинает инерпретацию байт-кода, т.е. построчное преобразование байт-кода в машинный код и его исполнение. 
public class JvmComprehension {                            

    public static void main(String[] args) {               // JVM нашла точку входа по слову main. Дальше отправляется команда подсистеме загрузчика классов
                                                           // на загрузку классов JvmComprehension, Object, Integer и класса System
                                                           // Классы загружены. Далее начинается раннее связывание, а именно проверка, что код валиден и 
                                                           // инициализация статических полей
                                                           // Класслоадеры загружают классы в область оперативной памяти, которая называется Metaspace. 
                                                           // Там же обитают статика и константы. 
                                                           // Далее внутри области памяти Stack создается фрейм под функцию main. В него попадает аргумент String[] args,
                                                           // локальная переменная i типа int, а также ссылки o и ii, который указывают на объекты ссылочных типов данных.
                                                           // Сами объекты при этом создаются в области памяти Heap. 
        int i = 1;                                         // Здесь локальной переменной типа int присваивается значение 1. 
        Object o = new Object();                           // Здесь создается экземпляр класса Object. Как писал выше, ссылка лежит в стеке, сам объект попал в кучу. 
        Integer ii = 2;                                    // Integer - класс-обертка для примитивного типа int. Здесь создается объект типа интовой обертки. 
        printAll(o, i, ii);                                // Вызывается новый метод -> см. ниже
        System.out.println("finished");                    // Вызывается еще один новый метод. В стеке создается очередной фрейм, в котором находится строка "finished".
    }                                                      // Выход из функции. JVM запускает сборщик мусора для удаления всех объектов и кучи. 
                                                           // Область памяти стек также очищается от фреймов и их содержимого, т.к. все функции отработали. 

    private static void printAll(Object o, int i, Integer ii) {    // в стеке создался новый фрейм для метода printAll. В метаспейсе уже загружены классы Integer и System,
                                                                   // а значит вызов подсистемы загрузчика классов не требуется.
                                                                   // в стек внутри фрейма, выделенного под класс printAll находятся аргументы o, i и ii 
                                                          
        Integer uselessVar = 700;                                  // Здесь создается объект uselessVar типа интовой обертки. Ссылка попадает в стек, объект - в кучу 
        System.out.println(o.toString() + i + ii);                 // Создается новый фрейм под функцию println, в который попадают ссылки на строку, созданную в o.toString(), 
                                                                   // а также i и ii 
    }
}
